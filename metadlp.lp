%
% Meta encoding for dynamic logic programs
% Expects reified program generated by the moviola script
%

body(R,P) :- pids(P,_uid), rule(_,body(R),P), 
             holds(A) : literal_tuple(body(R),A,P).

literal_definition(A,P) :- pids(P,_uid), literal_tuple(head(_),A,P).
literal_inprogram(A,P) :- pids(P,_uid), literal_tuple(_,A,P).

first_definition(A,P) :- pids(P,_uid), literal_inprogram(A,P), A=_n(_), #false: literal_inprogram(A,X1), X1<P.
first_definition(A,P) :- pids(P,_uid), literal_definition(A,P), #false: A=_n(_); #false: literal_definition(A,X1), X1<P.

last_definition(A,P-1,P) :- pids(P,_uid), first_definition(A,P).
%% last_definition(A,X,P)   :- pids(P,_uid), not first_definition(A,P), literal_inprogram(A,P), #false: A=_n(_);
%%                             literal_definition(A,X), X<P, #false: literal_definition(A,X1), X1>X, X1<P.
last_definition(A,X,P)   :- pids(P,_uid), not first_definition(A,P), literal_definition(A,P), #false: A=_n(_);
                            literal_definition(A,X), X<P, #false: literal_definition(A,X1), X1>X, X1<P.
%
% ~p :- ...
% ---------
% ~p :- ...
%
last_definition(A,X,P)   :- pids(P,_uid), not first_definition(A,P), literal_definition(A,P), A=_n(_),
                            literal_definition(A,X), X<P, #false: literal_definition(A,X1), X1>X, X1<P.
%
%    :- ~p.
% ---------
% ~p :- ...
%
last_definition(A,X,P)   :- pids(P,_uid), not first_definition(A,P), literal_definition(A,P), A=_n(_),
                            first_definition(A,X), X<P, #false: literal_definition(A,X1), X1>X, X1<P.

holds(A,X)   : literal_tuple(head(R),A,P) :- pids(P,_uid), rule(head(R),body(R),P), literal_tuple(head(R),A,P), body(R,P), 
                                             last_definition(A,X,P), not holds(reject(R,P)).

holds(A) :- pids(P,_uid), first_definition(A,P), holds(A,P-1).
:- holds(A), holds(_n(A)), pids(P,_uid), first_definition(_n(A),P).
:- not holds(A), not holds(_n(A)), pids(P,_uid), first_definition(_n(A),P).

#external holds(A,P) : pids(P,_uid), last_definition(A,_,P).
holds(A,X) :-  pids(P,_uid), last_definition(A,X,P), holds(A,P).

%
% Default assumptions
%

holds(cancelnaf(A),X)   :- activedef, pids(P,_uid), last_definition(A,X,P), body(R,P), literal_tuple(head(R),A,P), #false: A=_n(_).

#external holds(cancelnaf(A),P) : activedef, pids(P,_uid), last_definition(A,_,P), #false: A=_n(_).
holds(cancelnaf(A),X)   :- activedef, pids(P,_uid), last_definition(A,X,P), #false: A=_n(_); holds(cancelnaf(A),P).

holds(cancelnaf(A)) :- activedef, pids(P,_uid), holds(cancelnaf(A),P-1), first_definition(A,P), #false: A=_n(_).

#external holds(A)            : pids(P,_uid), first_definition(_n(A),P), #false: literal_inprogram(A,X1), X1<=P.
#external holds(cancelnaf(A)) : activedef, pids(P,_uid), first_definition(_n(A),P), #false: first_definition(A,X1), X1<=P.
#external holds(A)            : pids(P,_uid), literal_inprogram(A,P), #false: A=_n(_); #false: first_definition(A,X1), X1<=P. 

holds(_n(A),P-1) :- pids(P,_uid), first_definition(_n(A),P), not holds(A), not holds(cancelnaf(A)) : activedef.

%
% rejections
%

#external holds(reject(R,P),P) : pids(P,_uid), rule(head(R),_,P).
holds(reject(R,P))     :- pids(P,_uid), holds(reject(R,P),P), rule(head(R),_,P).

conflict(R,P,Ror,Por)   :- pids(Por,_uid), rule(head(Ror),_,Por), rule(head(R),_,P), Por>P,
                           literal_tuple(head(Ror),Aor,Por), literal_tuple(head(R),A,P), 1 { Aor=_n(A); A=_n(Aor) }.
conflictRD(R,P,Ror,Por) :- pids(Por,_uid), rule(head(Ror),_,Por), rule(head(R),_,P), Por=P, sem(rd),
                           literal_tuple(head(Ror),Aor,Por), literal_tuple(head(R),A,P), 1 { Aor=_n(A); A=_n(Aor) }.

holds(reject(R,P))      :- pids(P,_uid), conflictRD(R,P,Ror,P), body(Ror,P), sem(rd).

holds(reject(R,P),PorX) :- pids(Por,_uid), conflict(R,P,Ror,Por), body(Ror,Por), not holds(reject(Ror,Por)): sem(as);
                           conflict(R,P,RorX,PorX), PorX<Por, #false: conflict(R,P,RorX1,PorX1), PorX1>PorX, PorX1<Por.

holds(reject(R,P),P)    :- pids(Por,_uid), conflict(R,P,Ror,Por), body(Ror,Por), not holds(reject(Ror,Por)): sem(as);
                           #false: conflict(R,P,RorX,PorX), PorX<Por.

#external holds(reject(R,P),Por) : pids(Por,_uid), conflict(R,P,Ror,Por).
holds(reject(R,P),PorX) :- pids(Por,_uid), conflict(R,P,Ror,Por), holds(reject(R,P),Por),
                           conflict(R,P,RorX,PorX), PorX<Por, #false: conflict(R,P,RorX1,PorX1), PorX1>PorX, PorX1<Por.

holds(reject(R,P),P)    :- pids(Por,_uid), conflict(R,P,Ror,Por), holds(reject(R,P),Por),
                           #false: conflict(R,P,RorX,PorX), PorX<Por.

%
% Loops
%

ws(R,P)       :- pids(P,_uid), last_definition(A,X,P), literal_tuple(head(R),A,P),
                 dep(holds(A,X),holds(B),P) : literal_tuple(body(R),B,P); not holds(reject(R,P)).
ws(A,chain,P) :- pids(P,_uid), last_definition(A,X,P), dep(holds(A,X),holds(A,P),P).
ws(_n(A))     :- pids(P,_uid), first_definition(_n(A),P), not holds(A), not holds(cancelnaf(A)) : activedef. 

{ dep(holds(A,X),holds(B),P) }   :- pids(P,_uid), last_definition(A,X,P), literal_tuple(head(R),A,P), holds(B), literal_tuple(body(R),B,P).
{ dep(holds(A,X),holds(A,P),P) } :- pids(P,_uid), last_definition(A,X,P), holds(A,P).
  dep(holds(A),holds(A,P-1),P)   :- pids(P,_uid), first_definition(A,P), holds(A,P-1).

#edge(A,B) : pids(P,_uid), dep(A,B,P).

:- pids(P,_uid), last_definition(A,X,P), holds(A,X), not ws(R,P): literal_tuple(head(R),A,P);
   not ws(A,chain,P), not ws(A): A=_n(_), first_definition(A,P).

%
% outputing atoms
%

#show X : holds(X), first_definition(X,P), pids(P,_uid), #false: X=_n(_).
